## C++ Compilation Process

An illustration containing the C++ compilation process and all of its phases/steps can be seen in the image below.

![Compilation Flowchart](../img/compilation-process.png)

### Preprocessing

C++ code is usually kept in units called source files. A source file (_.cpp_ file) together with all the headers and libraries (_.h_ or _.hpp_ files) included by using the preprocessing directive `#include` is known as a preprocessed translation unit. Basically, the source files and header files are combined into a single translation unit by copying and pasting the content of the header files at the place where the `#include` for that header file is in the _.cpp_ file. See examples below.

_Example 1:_

- header file:

```c++
/* Header file - multiply.h */

/**
 * Multiplies two integers.
 * @params two integers
 * @returns product between the two integers
*/
int multiply(int a, int b); // function prototype
```

- source file:

```c++
/* Definition file - multiply.cpp */

#include "multiply.h"

int multiply(int a, int b) {
    return a*b;
}
```

After the preprocessor does its job and joins everything together in a single translation unit for the compiler to process, we'll have the following:

```c++
/* Definition file - multiply.cpp */

/* Header file - Multiply.h */

/**
 * Multiplies two integers.
 * @params two integers
 * @returns product between the two integers
*/
int multiply(int a, int b); // function prototype

int multiply(int a, int b) {
    return a*b;
}
```

_Example 2:_

- header file:

```c++
/* Header file - example.h */
/**
 * Example
 * @params  None
 * @returns None
*/
void example(void); // function prototype
extern int i;
```

- source file:

```c++
/* Definition file - example.cpp */
#include "example.h"

int i = 45;

void example(void) {
    std::cout << "Example - Compilation Process\n";
}
```

Once again, the preprocessor combines the header files and source files into a single translation unit to be processed by the compiler:

```c++
/* Definition file - example.cpp */
/* Header file - example.h */
/**
 * Example
 * @params  None
 * @returns None
*/
void example(void); // function prototype
extern int i;

int i = 45;

void example(void) {
    std::cout << "Example - Compilation Process\n";
}
```

### Compiling

C++ files are compiled independent of each other into a set of object files (_.o_ or _.obj_ files). The C++ compiler is responsible for going through all the _.cpp_ files and checking the code to see if there are any violations of the C++ language rules. If there are, the compilation process will be aborted and the compiler will generate an error message containing some info regarding the violation in order to assist you in correcting it. If the code being compiled does not break any rules, the compiler will then translate the C++ code into machine code and generate the object files.

Let's take a look at the translation unit generated by the preprocessor for the _Example 2_ above. The comments will be removed for the sake of cleanliness.

```c++
void example(void);
extern int i;

int i = 45;

void example(void) {
    std::cout << "Example - Compilation Process\n";
}
```

When the compiler processes this translation unit, it will first encounter the declaration for the function `example` without a definition. The compiler will then add this identifier to its _dictionary_, and, once added, it is possible for the implementation to refer to this identifier. Such declaration of a function without an implementation is called a _function prototype_. Next, we have the declaration of an integer variable, `i`, with **_external_** linkage. As there is no assignment to `i`, it is also placed in the dictionary, but no memory is allocated for it. It also marks the variable as having _**external**_ linkage. When multiple translation units declare the same variable/object with external linkage, the compiler will know that they refer to the same variable/object, and it'll only allocate space for it once. Later, the compiler encounters the definition `int i = 45;`, which is the definition of the previously declared integer identifier, `i`. As this is a definition, memory is then allocated for `i`. However, in case there are more than one definition for the same variable/object, the compiler will generate an error. Finally, the compiler encounters the definition of `example`.

_Note_: If a variable is declared, i.e. `int x;`, and the compiler reaches the end of the translation unit without encountering its definition, it'll behave as if the variable was initialized to zero.

_Example 3:_

```c++
/* This code doesn't compile due to redefinition of 'a' */
int a;
int a;
int a = 1;

int main() {
    std::cout << "a: " << a << "\n";
}
/* NOTE: if converted to C, this code would compile since we'd be working on the global scope */
```

### Linking

When the compiler is done performing its checks and generating the object files, the linker will take these object files and combine them into a single executable program (_.exe_) or, in case of a reusable piece of code which performs a commom/repetitive task, into a library (_.a_ or _.lib_). The linking process also decides where each variable and function will be placed in memory, and symbolic references are replaced by actual addresses.

An identifier declared in different scopes or in the same scope more than once can be made to refer to the same object or function by a process called linkage, which can be made to be external or internal.

We will talk more about the linker and the linkage process when we get to [header files](../header-files/README.md).
